# -*- coding: utf-8 -*-
"""DoublePendulum.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19OuQJiNhFzcSp0z1Px4A0wYYHZP9XpIp
"""

import numpy as np
from numpy import sin,cos
import matplotlib.pyplot as plt

g=9.81
l=0.4
m=1

def doublependulum(penset):
  theta1 = penset[0]
  theta2 = penset[1]
  w1 = penset[2]
  w2 = penset[3]
  fth1 = w1
  fth2 = w2
  fw1 = -(w1**2*sin(2*theta1-2*theta2) + 2*w2**2*sin(theta1-theta2) + (g/l)*(sin(theta1-2*theta2) + 3*sin(theta1)))/(3-cos(2*theta1-2*theta2))
  fw2 = (4*w1**2*sin(theta1-theta2) + w2**2*sin(2*theta1 - 2*theta2) + 2*(g/l)*(sin(2*theta1-theta2)-sin(theta2)))/(3-cos(2*theta1-2*theta2))
  return np.array([fth1,fth2,fw1,fw2])

def RungeKutta(tstart,tend,step,theta1ini,theta2ini,w1ini,w2ini,doublependulum):
  tlist=np.arange(tstart,tend+step,step)
  penset=np.array([theta1ini,theta2ini,w1ini,w2ini])
  penset_list=np.array([penset])
  for i in tlist[:-1]:
    k1=step*doublependulum(penset)
    k2=step*doublependulum(penset+0.5*k1)
    k3=step*doublependulum(penset+0.5*k2)
    k4=step*doublependulum(penset+k3)
    penset +=(1/6)*(k1+2*k2+2*k3+k4)
    penset_list = np.append(penset_list,np.array([penset]),axis=0)
  return tlist,penset_list

def get_energy(rs):
  theta1=rs[:,0]
  theta2=rs[:,1]
  w1=rs[:,2]
  w2=rs[:,3]
  return m*l**2*(w1**2+(1/2)*w2**2+w1*w2*cos(theta1-theta2))-m*g*l*(2*cos(theta1)+cos(theta2))

def get_coordinates(rs):
  theta1=rs[:,0]
  theta2=rs[:,1]
  x1=l*sin(theta1)
  y1=-l*cos(theta1)
  x2=l*(sin(theta1) + sin(theta2))
  y2=-l*(cos(theta1) + cos(theta2))
  return x1,y1,x2,y2

t0=0
t1=100
step1=0.002
step2=0.004
step3=0.008

tlistrk1,penset_listrk1=RungeKutta(t0,t1,step1,np.pi/2,np.pi/2,0,0,doublependulum)
tlistrk2,penset_listrk2=RungeKutta(t0,t1,step2,np.pi/2,np.pi/2,0,0,doublependulum)
tlistrk3,penset_listrk3=RungeKutta(t0,t1,step3,np.pi/2,np.pi/2,0,0,doublependulum)

#output (ts,rs) size=(step,5)
np.savetxt('resultRK.txt',np.hstack((np.expand_dims(tlistrk,axis=1),penset_listrk)))

plt.plot(tlistrk1,penset_listrk1[:,0])
#plt.plot(tlistrk1,penset_listrk3[:,0]-penset_listrk2[:,0])
plt.xlabel('t (s)'), plt.ylabel('\u03B8\u2081 (rad)')
plt.title("Evolution of \u03B8\u2081")
plt.savefig('th1evo.png')

#test the time convergence
diff = 0
for i in range(12500):
  if i!=0:
    a = penset_listrk3[i,3]-penset_listrk2[2*i-1,3]/2-penset_listrk2[2*i,3]/2
    b = penset_listrk2[2*i-1,3]/2+penset_listrk2[2*i,3]/2-(penset_listrk1[4*i-2,3]+penset_listrk1[4*i-1,3]+penset_listrk1[4*i,3]+penset_listrk1[4*i+1,3])/4
    diff += abs(2*a/b)
print(diff/12500)

x1,y1,x2,y2 = get_coordinates(penset_listrk1)
plt.title('Trajectory of the double pendulum in 100s')
plt.xlabel('x(m)')
plt.ylabel('y(m)')
plt.plot(x1,y1)
plt.plot(x2,y2)
plt.legend(['bob1','bob2'])
plt.savefig('RK.png')

tot_E = get_energy(penset_listrk1)
plt.plot(tlistrk1,tot_E)
plt.xlabel('t (s)'), plt.ylabel('Total E (J)')
plt.title("Total Energy vs. Time")
plt.savefig('EconvRK.png')

def leap_frog(t0, t1, h, th10, th20, w10, w20, f):
    '''
    Do the first half step with euler's algorism,
    then use leapfrog method to calculate integer steps and half steps depending on each other.
    Returns: t, rs, rhs (arrays of size N=#steps) (warining: rs and rhs may diverge)

    '''
    N = (t1 - t0)/h
    ts = np.arange(t0, t1+h,h)
    r = np.array([th10, th20, w10, w20], float)
    rhalf = r-(h/2)*f(r)
    rs = np.array([r])
    rhs = np.array([rhalf])

    for t in ts[:-1]:
        k1 = h*f(r)
        k2 = h*f(rhalf + k1)
        r += k2
        rhalf += k1
        rs = np.append(rs, np.array([r]), axis=0)
        rhs = np.append(rhs, np.array([rhalf]), axis=0)
    return ts, rs, rhs

'''
leapfrog test
'''
def g(x):
  return np.sin(x)

def leapfrogtest(x,t0, t1, h,f):
    N = (t1 - t0)/h
    ts = np.arange(t0, t1+h,h)
    r = np.array(x, float)
    rhalf = r+(h/2)*f(r)
    r = rhalf + (h/2)*f(r)
    rs = np.array([r])
    rhs = np.array([rhalf])
    for t in ts[:-1]:
        k1 = h*f(r)
        k2 = h*f(rhalf + k1)
        r += k2
        rhalf += k1
        rs = np.append(rs, np.array([r]), axis=0)
        rhs = np.append(rhs, np.array([rhalf]), axis=0)
    return ts, rs, rhs

'''
leapfrog test
'''
t0=0
t1=100
step=0.002
tlist,penset_list, pen_half_list = leapfrogtest(0,t0,t1,step,g)
plt.plot(tlist,penset_list)
plt.plot(tlist,pen_half_list)

tlist,penset_list, pen_half_list=leap_frog(t0,t1,step,np.pi/2,np.pi/2,0,0,doublependulum)

plt.plot(tlist,penset_list)
plt.plot(tlist,pen_half_list)

x1,y1,x2,y2 = get_coordinates(penset_list)
plt.title('Trajectory of the double pendulum in 100s')
plt.xlabel('x(m)')
plt.ylabel('y(m)')
plt.plot(x1,y1)
plt.plot(x2,y2)
plt.legend(['bob1','bob2'])

np.shape(tlistrk)

import matplotlib.animation as animation

x1,y1,x2,y2 = get_coordinates(penset_listrk)

x1sub = x1[0:1000]
y1sub = y1[0:1000]
x2sub = x2[0:1000]
y2sub = y2[0:1000]
fig, ax = plt.subplots()

N = x1sub.size
scat1 = ax.scatter(x1sub[0], y1sub[0], c="b", s=5, label=f'mass 1')
scat2 = ax.scatter(x2sub[0], y2sub[0], c="r", s=5, label=f'mass 2')
ax.set(xlim=[-2*l, 2*l], ylim=[-2*l, 2*l], xlabel='x [unit of length]', ylabel='y [unit of length]')
ax.legend()


def update(frame):
    # for each frame, update the data stored on each artist.
    x = x1sub[:frame]
    y = y1sub[:frame]
    x_ = x2sub[:frame]
    y_ = y2sub[:frame]
    # update the scatter plot:
    data = np.stack([x, y]).T
    scat1.set_offsets(data)
    data_ = np.stack([x_, y_]).T
    scat2.set_offsets(data_)

    return (scat1, scat2)


ani = animation.FuncAnimation(fig=fig, func=update, frames=N, interval=30)
plt.show()
ani.save(filename="pendulumRK.gif", writer="pillow")